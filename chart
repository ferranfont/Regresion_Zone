import os
import pandas as pd
import numpy as np
from datetime import datetime, time, timedelta
from sklearn.linear_model import LinearRegression
import picos_y_valles as pv
import plotly.graph_objects as go
import matplotlib.pyplot as plt
from scipy.stats import norm
import webbrowser

# === LECTURA DATOS ===
directorio = '../DATA'
nombre_fichero = 'export_es_2015_formatted.csv'
ruta_completa = os.path.join(directorio, nombre_fichero)
df = pd.read_csv(ruta_completa)
if 'Date' in df.columns:
    df['Date'] = pd.to_datetime(df['Date'], utc=True)
    df.set_index('Date', inplace=True)
df.index = df.index.tz_convert('Europe/Madrid')
fecha = '2023-10-02'
START_DATE = pd.Timestamp(fecha, tz='Europe/Madrid')
END_DATE = pd.Timestamp(fecha, tz='Europe/Madrid')
df = df[(df.index.date >= START_DATE.date()) & (df.index.date <= END_DATE.date())]

# === Picos y Valles ===
df_picos, df_valles = pv.encontrar_picos_valles(df, prominence=1, top_n=15)

# --- Rango principal para regresión
hora_inicio = time(7, 50)
hora_fin = time(16, 30)
mask_main = (df.index.time >= hora_inicio) & (df.index.time <= hora_fin)

# --- Rango para proyección futura
hora_future = time(20, 0)
dt_future = pd.Timestamp.combine(START_DATE.date(), hora_future).tz_localize('Europe/Madrid')

# --- Regresión sobre picos
df_picos_rango = df_picos[(df_picos['fecha'].dt.time >= hora_inicio) & (df_picos['fecha'].dt.time <= hora_fin)]
X_picos = (df_picos_rango['fecha'].astype(np.int64) // 10**9).values.reshape(-1, 1)
y_picos = df_picos_rango['precio'].values
reg_picos = LinearRegression().fit(X_picos, y_picos)

# --- Regresión sobre valles
df_valles_rango = df_valles[(df_valles['fecha'].dt.time >= hora_inicio) & (df_valles['fecha'].dt.time <= hora_fin)]
X_valles = (df_valles_rango['fecha'].astype(np.int64) // 10**9).values.reshape(-1, 1)
y_valles = df_valles_rango['precio'].values
reg_valles = LinearRegression().fit(X_valles, y_valles)

# --- Fechas para dibujar la recta sólida y dash
dt_start = pd.Timestamp.combine(START_DATE.date(), hora_inicio).tz_localize('Europe/Madrid')
dt_fin = pd.Timestamp.combine(START_DATE.date(), hora_fin).tz_localize('Europe/Madrid')
dt_proj = dt_future
fechas_solid = pd.date_range(dt_start, dt_fin, freq='min')
fechas_dash = pd.date_range(dt_fin + timedelta(minutes=1), dt_proj, freq='min')

# --- Predicciones
X_solid_picos = (fechas_solid.astype(np.int64) // 10**9).to_numpy().reshape(-1, 1)
y_solid_picos = reg_picos.predict(X_solid_picos)
X_dash_picos = (fechas_dash.astype(np.int64) // 10**9).to_numpy().reshape(-1, 1)
y_dash_picos = reg_picos.predict(X_dash_picos)

X_solid_valles = (fechas_solid.astype(np.int64) // 10**9).to_numpy().reshape(-1, 1)
y_solid_valles = reg_valles.predict(X_solid_valles)
X_dash_valles = (fechas_dash.astype(np.int64) // 10**9).to_numpy().reshape(-1, 1)
y_dash_valles = reg_valles.predict(X_dash_valles)

# --- Filtra datos para dibujar precio desde 07:50 a 20:00
hora_future = time(20, 0)
mask_full = (df.index.time >= hora_inicio) & (df.index.time <= hora_future)
df_plot = df[mask_full]

# --- Picos y valles para scatter sólo en rango 07:50-20:00
dt_start = pd.Timestamp.combine(START_DATE.date(), hora_inicio).tz_localize('Europe/Madrid')
mask_picos_plot = (df_picos['fecha'] >= dt_start) & (df_picos['fecha'] <= dt_proj)
mask_valles_plot = (df_valles['fecha'] >= dt_start) & (df_valles['fecha'] <= dt_proj)

# =================== PLOTLY: EXPORTAR HTML Y ABRIR EN CHROME ===================
chart_dir = 'charts'
os.makedirs(chart_dir, exist_ok=True)
html_path = os.path.join(chart_dir, 'chart_picos_valles_regresion.html')

fig = go.Figure()
# Precio
fig.add_trace(go.Scatter(
    x=df_plot.index, y=df_plot['Close'],
    mode='lines', name='Close', line=dict(color='blue', width=1)
))
# Picos y valles
fig.add_trace(go.Scatter(
    x=df_picos['fecha'][mask_picos_plot], y=df_picos['precio'][mask_picos_plot],
    mode='markers', name='Picos (High)', marker=dict(color='green', size=8, symbol='circle')
))
fig.add_trace(go.Scatter(
    x=df_valles['fecha'][mask_valles_plot], y=df_valles['precio'][mask_valles_plot],
    mode='markers', name='Valles (Low)', marker=dict(color='red', size=8, symbol='circle')
))
# Regresión picos (verde)
fig.add_trace(go.Scatter(
    x=fechas_solid, y=y_solid_picos, mode='lines',
    name='Recta Picos', line=dict(color='green', width=1)
))
fig.add_trace(go.Scatter(
    x=fechas_dash, y=y_dash_picos, mode='lines',
    name='Recta Picos Extensión', line=dict(color='green', width=1, dash='dash')
))
# Regresión valles (magenta)
fig.add_trace(go.Scatter(
    x=fechas_solid, y=y_solid_valles, mode='lines',
    name='Recta Valles', line=dict(color='magenta', width=1)
))
fig.add_trace(go.Scatter(
    x=fechas_dash, y=y_dash_valles, mode='lines',
    name='Recta Valles Extensión', line=dict(color='magenta', width=1, dash='dash')
))
# Líneas verticales horarias
for h in ['07:50:00', '15:30:00', '16:30:00']:
    vline_time = datetime.strptime(h, '%H:%M:%S').time()
    vline_stamp = pd.Timestamp.combine(START_DATE.date(), vline_time).tz_localize('Europe/Madrid')
    fig.add_vline(
        x=vline_stamp, line=dict(color='gray', width=1), opacity=0.5
    )

fig.update_layout(
    title='Precio con picos, valles y proyección futura de regresiones (dash)',
    xaxis_title='Fecha',
    yaxis_title='Precio',
    showlegend=False,  # Quitar leyenda aquí
    template='plotly_white',
    xaxis=dict(showgrid=False, linecolor='gray', linewidth=1),
    yaxis=dict(showgrid=False, linecolor='gray', linewidth=1)
)
fig.write_html(html_path)
print(f"✅ Gráfico Plotly guardado como '{html_path}'")

# Abre en Chrome automáticamente
chrome_path = None
# Si tienes el path de Chrome personalizado, ponlo aquí:
# chrome_path = 'C:/Program Files/Google/Chrome/Application/chrome.exe %s'
if chrome_path:
    webbrowser.get(chrome_path).open('file://' + os.path.realpath(html_path))
else:
    # Esto intenta abrir con el navegador predeterminado (normalmente Chrome en Windows)
    webbrowser.open('file://' + os.path.realpath(html_path))
    

# =================== MATPLOTLIB TRANSPUESTO (desde 15:00) ===================

# =================== MATPLOTLIB TRANSPUESTO (desde 15:00) ===================
hora_inicio_plt = time(15, 0)
df_post1500 = df[df.index.time >= hora_inicio_plt].copy()
precios = df_post1500['Close'].values
tiempos = df_post1500.index

plt.figure(figsize=(10, 6))
plt.plot(precios, tiempos, color='blue', linewidth=1, label='Precio vs Tiempo')

# Picos y valles en rango desde 15:00
mask_picos_plt = (df_picos['fecha'] >= df_post1500.index[0]) & (df_picos['fecha'] <= df_post1500.index[-1])
mask_valles_plt = (df_valles['fecha'] >= df_post1500.index[0]) & (df_valles['fecha'] <= df_post1500.index[-1])
plt.scatter(df_picos['precio'][mask_picos_plt], df_picos['fecha'][mask_picos_plt],
            color='green', s=60, label='Picos (High)', zorder=5)
plt.scatter(df_valles['precio'][mask_valles_plt], df_valles['fecha'][mask_valles_plt],
            color='red', s=60, label='Valles (Low)', zorder=5)

# --- Dynamic dashed regression lines for picos and valles ---
# Uses same fechas_solid, fechas_dash, y_solid_picos, y_dash_picos, etc., as in Plotly

plt.plot(y_solid_picos, fechas_solid, color='green', linewidth=1, label='Recta Picos')
plt.plot(y_dash_picos, fechas_dash, color='green', linewidth=1, linestyle='--', label='Proy. Picos')

plt.plot(y_solid_valles, fechas_solid, color='magenta', linewidth=1, label='Recta Valles')
plt.plot(y_dash_valles, fechas_dash, color='magenta', linewidth=1, linestyle='--', label='Proy. Valles')

# Campana de Gauss gris transparencia 0.5
media = np.mean(precios)
std = np.std(precios)
x_gauss = np.linspace(precios.min(), precios.max(), 300)
y_gauss = norm.pdf(x_gauss, media, std)
y_gauss_scaled = (y_gauss - y_gauss.min()) / (y_gauss.max() - y_gauss.min())
y_gauss_scaled = y_gauss_scaled * (tiempos.max() - tiempos.min()) + tiempos.min()
plt.plot(x_gauss, y_gauss_scaled, color='gray', linewidth=1, alpha=0.5, label='Campana de Gauss')

plt.title('Precio (X) vs Tiempo (Y) desde 15:00h + Campana de Gauss + Proyección regresiones')
plt.xlabel('Precio')
plt.ylabel('Fecha/Hora')
plt.grid(True, linestyle='--', alpha=0.4)
plt.legend()
plt.tight_layout()
plt.show()


